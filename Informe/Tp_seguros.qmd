```{r, echo =F, warning=F, message=F}
# Librerias
library(dplyr)
library(readxl)
library(ggplot2)
library(lubridate)
library(moments)
library(EnvStats)
library(actuar)
library(MASS)
library(ExtDist)
library(kableExtra)
```

```{r, echo =F, warning=F, message=F}
# Carga de los datos
datos <- read_excel("../Datos/Trabajo Final 2024 Base de Datos .xlsx")
cer <- read_excel("../Datos/CER.xlsx")

datos$Fecha <- lubridate::as_date(datos$Fecha)
cer$Fecha <- lubridate::as_date(cer$Fecha)
set.seed(1248)
options(scipen = 999)

datos$Fecha[1] + lubridate::days(45)
cer$Fecha[354] + days(45)
```

```{r, echo =F, warning=F, message=F}
limite = cer$CER[cer$Fecha == (datos$Fecha[3431] + days(45))] 


cer$CER[cer$Fecha == (datos$Fecha[1:3] + days(45))]
```

```{r, echo =F, warning=F, message=F}
# Ajuste por el indice CER a 45 dias
indice = numeric(nrow(datos))
for (i in 1:nrow(datos)) {
  indice[i] <- cer$CER[cer$Fecha == (datos$Fecha[i] + days(45))]
}

datos$inflacion <- limite/indice

datos$Cuantia_ajust <- datos$Cuantía * limite/indice
```

# Introducción

Una empresa aseguradora resulta solvente cuando dispone o es capaz de recolectar los recursos necesarios para hacer frente a posibles siniestro no previstos. Sea cual sea la duración del seguro, hay una diferencia entre el momento en que se contrata y el momento en el que se cobra, es ahí donde la capacidad de solvencia de la compañia cobra importancia ya que sirve para que los clientes tengan la certeza de que ante la ocurrencia de un siniestro, esta va a ser capaz de cubrirlo.

En este informe, se buscará determinar el Margen de Solvencia Mínimo para una subcartera de pólizas de seguros de automotores de una determinada compañia, de forma tal que su Probabilidad de Solvencia sea del 99% durante el año 2024. Los datos con los que se cuenta pertenecen al año 2023 entonces, debido al contexto inflacionario del país, para trabajar en el 2024 se realizó un ajuste por inflación a través del indice CER, considerando 45 días de rezago; esto debido a que el dato inflacionario se publica 30 días tarde y el indice CER demora 15 días más.  


## Análisis descriptivo

Se realizó un análisis descriptivo de las cuantías ajustadas por inlfación de los siniestros.

```{r, echo =F, warning=F, message=F}
cuantia_total <- sum(datos$Cuantia_ajust)

meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
           "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
datos |> 
  mutate(mes = factor(month(Fecha), levels = 1:12, labels = meses)) |> 
  group_by(mes) |>
  summarise(Cuantia_total = sum(Cuantia_ajust, na.rm = TRUE)) |> 
  # La linea de arriba ayuda a que podamos poner el borde negro a la barras, si no
  # las barras quedan como a rayas (No sé explicarme mejor, perdón)
  ggplot() +
  aes(x = mes, y = Cuantia_total / 1e6) + 
  geom_bar(stat = "identity", fill = "darkolivegreen2", color = "black") +
  theme_bw() +
  labs(y = "Cuantia*", 
       caption = "*los valores están expresados en millones de pesos",
       x = "Mes") +
  theme(plot.caption = element_text(hjust = 0.5),
        axis.text.x = element_text(angle = 30, vjust = 0.9))

```

```{r, echo =F, warning=F, message=F}
datos |> 
  mutate(mes = factor(month(Fecha), levels = 1:12, labels = meses)) |>
  group_by(mes) |> 
  summarize(siniestros = n(),
            total_cuantia = sum(Cuantia_ajust)) |> 
  ggplot() +
  aes(x = mes, y = siniestros) +
  geom_bar(stat = "identity", fill = "darkolivegreen2", color = "black") +
  theme_bw() +
  labs(y = "Siniestros", x = "Mes") +
  theme(axis.text.x = element_text(angle = 30, vjust = 0.9))
```

Se puede observar que el total de Marzo fue el más elevado, tanto para las cunatías como los siniestros; lo que llevaría pensar que se pagaron muchas cuantías por la elevada ocurrencia de siniestros. Por otro lado, Septiembre tuvo un comportamiento inverso: la ocurrencia de siniestros y el total de cuantías a fin de mes fueron menores respecto a los 11 meses restantes.


```{r, echo =F, warning=F, message=F}
# Medidas resumenes de las cuantias
media_datos = mean(datos$Cuantia_ajust) # Promedio
var_datos = var(datos$Cuantia_ajust) # Desvío estandar
asimetria_datos = skewness(datos$Cuantia_ajust) # Coeficiente de asimetría

# Medidas resumenes de los siniestros
siniestros_datos <- datos |> 
  mutate(mes = factor(month(Fecha))) |>
  group_by(mes) |> 
  summarize(siniestros = n(),
            total_cuantia = sum(Cuantia_ajust))
media_siniestros = mean(siniestros_datos$siniestros)
var_siniestros = var(siniestros_datos$siniestros)

resumen <- data.frame(
  x = c("Cuantías", "Siniestros"),
  y = c(round(media_datos, 2),round(media_siniestros, 2) ),
  j = c(round(var_datos/1000000, 2), round(var_siniestros, 2))
)

kable(resumen, col.names = c("", "Media", "Variancia"), 
                  format = "pipe") %>%
  kable_styling() %>% 
  add_footnote("La variancia de las cuantías está experesada en millones", notation = "none")

```


# Metodología

Se cuenta con la información de polizas y siniestros de años anteriores, la cual se utiliza para estimar los parametros de las distribuciones que se aplicarán para simular el número de siniestros.


```{r, echo =F, warning=F, message=F}
registro = data.frame(
  anio = c(2021, 2022, 2023),
  polizas = c(24752, 25348, 25615),
  siniestros = c(3023, 3581, 3431)
)

registro <- registro |> 
  mutate(lambda = round(siniestros/polizas, 4))

kable(registro,format = "pipe",
                  col.names = c("Año", "Pólizas", "Siniestros", "$\\lambda$"))
```


Para lograr el objetivo propuesto -MSM que garantice una probabilidad de solvencia del 99%-,se simula la cartera de polizas de la sigueinte manera: 

1. Se hacen 5000 simulaciones para la cantidad de siniestros que pueden ocurrir en el año, siguiendo una distribución de probabilidad.

2. A partir de cada resultado, se simulan las cuantías individuales de los siniestros.

3. Se suman las cuantías individuales de cada año simulado, obteniendo así las cuantías totales.
Con esta última información se calculará el MSM.



## Propuesta 1

-   Distribución de los siniestros: Binomial negativa

| Dado que no se considera adecuado suponer que la media y la variancia de los siniestro son iguales, se propone que la variancia es un 10% más grande que la media para poder estimar los parámetros. Dado que las cantidades varian maso asi
| La estimación se basa en el método de los momentos:

$$
\begin{cases}
E(N) = \lambda \\
V(N) = \lambda \; \cdot \; ( 1 + \frac{\lambda}{h})
\end{cases}
\Rightarrow
\begin{cases}
\hat{\lambda} = 0.1324  \\
\hat{h} = 1.3243
\end{cases}
$$


```{r}
n_polizas <- 25615 
k <- 5000 # 5000 simulaciones
media_lambda = mean(registro$lambda)
h <- ((media_lambda)^2)/(media_lambda*1.1 - media_lambda) # Suponiendo que la variancia es un 10% más que la media
p <- h/(media_lambda + h)


siniestros <- numeric(k)
for (i in 1:k) {
  
  # Obtenemos el numero total de siniestros para toda la cartera
  siniestros[i] <- sum(rnbinom(n = n_polizas, prob = p, size = h))
  }
```


```{r}
densidad_bn <- dnbinom(x = 0:10 ,prob = p, size = h)

ggplot() +
  aes(x = 0:4, y = densidad_bn[1:5]) +
  geom_bar(stat = "identity", width = 0.2, fill  = "plum2") + 
  theme_bw()+
  labs(y = "Densidad", x = "Siniestros por póliza")
```

```{r}
ggplot() +
  aes(x = siniestros) +
  geom_histogram(bins = 40, fill = "gray21") +
  labs(y = "Frecuencia", x = "Siniestro") +
  theme_bw()

```


$$
\begin{array} {c|c|c}
 & \text{Media} & {\begin{array}{c}\text{Desvío} \\ \text{Estándar}\end{array}}  & \text{Mínimo} & \text{Máximo} & \text{Mediana} \\
\hline
Siniestros & 3391.48 & 60.85 & 3179 & 3609 & 3391
\end{array}
$$

-   Distribución de la cuantías: Log-Normal

| Teniendo en cuenta que los datos de las cuantías individuales son asimétricos, se postula que podrían seguir la distribución planteada.

| Los parámetros de la misma, se estiman a través del método de los momentos; partiendo del valor R, definido como $R = \frac{m_2}{(m_1)^2}$ donde $m_1$ es el momento de orden 1 y $m_2$ es el momento de orden 2.

$$
R = 1.2629 
\Rightarrow
\begin{cases}
\hat{\mu} = ln(m_1) - \frac{1}{2}ln(R) \\
\hat{\sigma} = \sqrt{ln(R)}
\end{cases}
\Rightarrow
\begin{cases}
\hat{\mu} =  13.0465 \\
\hat{\sigma} = 0.4831
\end{cases}

$$


```{r}
mom1 <- media_datos
mom2 <- var_datos + mom1^2

r <- mom2/(mom1^2)

sigma_est <- sqrt(log(r))
mu_est <- log(mom1) - (1/2)*log(r)

datos |> 
  ggplot() +
  aes(x = Cuantia_ajust) +
  geom_histogram(aes(y = after_stat(density)), bins = 80, fill = "grey21") +
  stat_function(fun = dlnorm, args = list(meanlog = mu_est, sdlog = sigma_est), 
                color = "orangered", size = 1) +
  theme_bw() +
  labs(y = "Densidad", x = "Cuantía ajustada")
```

Se puede ver que la distribución Log-Normal estaría siendo adecuada para las cuantías individuales. 



## Propuesta 2

-   Distribución de los siniestros: Binomial negativa

| Se plantea el mismo supuesto, respecto a la variancia y la media, que se postuló en la propuesta 1.

-   Distribución de la cuantías: Gamma 

| Considerando que los datos de las cuantías individuales son continuos, positivos y asimétricos, se contempla que la distribución postulada podría ser adecuada para ellos. 

| Los parámetros de la misma se estiman mediante el método de los momentos:

$$
\begin{cases}
E(X) = \overline{X} = \alpha \; \cdot \; \beta \\
V(X) = S^2 = \alpha \; \cdot \; \beta^2
\end{cases}
\Rightarrow
\begin{cases}
\hat{\alpha} = \frac{(\overline{X})^2}{S^2} \\
\hat{\beta} = \frac{S^2}{\overline{X}}
\end{cases}
\Rightarrow
\begin{cases}
\hat{\alpha} = 3.8035 \\
\hat{\beta} = 136936.7038
\end{cases}
$$


```{r}
alpha = (media_datos^2)/(var_datos)
beta = var_datos/media_datos

datos |> 
  ggplot() +
  aes(x = Cuantia_ajust) +
  geom_histogram(aes(y = after_stat(density)), bins = 80, fill = "grey21") +
  stat_function(fun = dgamma, args = list(shape = alpha, scale = beta), 
                color = "springgreen3", size = 1) +
    # stat_function(fun = dlnorm, args = list(meanlog = mu_est, sdlog = sigma_est), 
    #             color = "orangered", size = 1) +
  theme_bw() +
  labs(y = "Densidad", x = "Cuantía ajustada")
```


Al igual que la Log-Normal, la distribución Gamma parecería que se adecua a los datos de las cuantías totales; con la salvedad de que presenta menor densidad que la Log-Normal en valores chicos de cuantías.



## Propuesta 3

-   Distribución de los siniestros: Poisson 

| Pese a lo planteado en las propuestas anteriores, se propone que el número de siniestro seguiría una distribución Poisson; por lo tanto, se esta suponiendo que la media y la variancia son iguales.

$$
E(N) = V(N) = \lambda \; \Rightarrow \; \hat{\lambda} = 0.1324
$$

```{r}
n_polizas <- 25615 
k <- 5000 # 5000 simulaciones
media_lambda = mean(registro$lambda)

siniestros_poisson <- numeric(k)
for (i in 1:k) {
  
  # Obtenemos el numero total de siniestros para toda la cartera
  siniestros_poisson[i] <- sum(rpois(n = n_polizas, lambda = media_lambda))
  }
```

```{r}
densidad_poisson <- dpois(x = 0:10 ,lambda = media_lambda)

ggplot() +
  aes(x = 0:4, y = densidad_poisson[1:5]) +
  geom_bar(stat = "identity", width = 0.2, fill  = "plum2") + 
  theme_bw()+
  labs(y = "Densidad", x = "Siniestros por póliza")
```

```{r}
ggplot() +
  aes(x = siniestros_poisson) +
  geom_histogram(bins = 40, fill = "grey21") +
  labs(y = "Frecuencia", x = "Siniestros") +
  theme_bw()
```

$$
\begin{array} {c|c|c}
 & \text{Media} & {\begin{array}{c}\text{Desvío} \\ \text{Estándar}\end{array}}  & \text{Mínimo} & \text{Máximo} & \text{Mediana} \\
\hline
Siniestros & 3391.44 & 57.94 & 3166 & 3615 & 3392
\end{array}
$$

-   Distribución de la cuantías: Log-Normal

| Teniendo en cuenta que los datos de las cuantías individuales son asimétricos, se postula que podrían seguir la distribución planteada.

| Los parámetros de la misma, se estiman a través del método de los momentos; partiendo del valor R, definido como $R = \frac{m_2}{(m_1)^2}$ donde $m_1$ es el momento de orden 1 y $m_2$ es el momento de orden 2. Las estimaciones serán las mismas que las obtenidas para la propuesta 1:

$$
\begin{cases}
\hat{\mu} =  13.0465 \\
\hat{\sigma} = 0.4831
\end{cases}
$$

```{r}
mom1 <- media_datos
mom2 <- var_datos + mom1^2

r <- mom2/(mom1^2)

sigma_est <- sqrt(log(r))
mu_est <- log(mom1) - (1/2)*log(r)
```


Al ser los mismos parámetros estimados, el ajuste de la distribución Log-Normal será el mismo que para el caso donde el número de siniestros sigue la Binomial Negativa.


## Resultados

### Propuesta 1: Distribución Binomial Negativa + Distribución Log-Normal

```{r}
# Simulación de las cuantías individualea y totales
media_siniestros_simulados1 <- mean(siniestros)
var_siniestros_simulados1 <- var(siniestros)

cuantia_total_simulada <- numeric(length(siniestros))
esperanzas_simuladas <- numeric(length(siniestros))
variancias_simuladas <- numeric(length(siniestros))
contador <- 0

for(i in siniestros){
  contador <- contador + 1
  pos <- rlnorm(n = i, meanlog = mu_est, sdlog = sigma_est)
  esperanzas_simuladas[contador] <- mean(pos)
  variancias_simuladas[contador] <- var(pos)
  cuantia_total_simulada[contador] <- sum(pos)
}

media_ej1 <- mean(esperanzas_simuladas) # Esperanza del ejercicio
var_ej1 <- mean(variancias_simuladas) # Variancia del ejercicio

media_cuantia_total <- media_ej1 * media_siniestros_simulados1

datos_simulados <- data.frame(
  prop1 = cuantia_total_simulada
)
```

Se cobra la prima recargada que es la media de la siniestral anual 1787 millones de pesos + 1% de recargo
Se cobra la prima recargada que es la media de la siniestral anual 1787 millones de pesos + 3% de recargo

```{r}
z = qnorm(0.99)
y1 = z + (skewness(cuantia_total_simulada)/6)*(z^2 - 1)

prop1 <- data.frame(
  RS = c("1%", "3%"),
  PP = c(mean(cuantia_total_simulada), mean(cuantia_total_simulada)),
  PR = c(mean(cuantia_total_simulada)*1.01, mean(cuantia_total_simulada)*1.03),
  P_N = c(z*sd(cuantia_total_simulada)+mean(cuantia_total_simulada), z*sd(cuantia_total_simulada)+mean(cuantia_total_simulada))
) |> 
  mutate(MSM_n = P_N - PR) |> 
  mutate(P_NP = c(y1*sd(cuantia_total_simulada)+mean(cuantia_total_simulada), y1*sd(cuantia_total_simulada)+mean(cuantia_total_simulada))) |> 
  mutate(MSM_np = P_NP - PR)

```

```{r}
# Función para calcular la densidad de Normal Power
dnp <- function(x, mu, sigma, asim) {
  y <- ((x-mu)/sigma) + (asim/6)*(((x-mu)/sigma)^2-1)
  (1/(sqrt(2*pi)*sigma))*exp(-0.5*(((y*sigma+mu)-mu)/sigma)^2)
}
```


```{r}
datos_simulados |> 
  ggplot() +
  aes(x = cuantia_total_simulada) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, fill = "grey21") +
  labs(x = "Cuantía total", y = "Densidad") +
  scale_x_continuous(breaks = c(1650000000, 1770000000,1890000000)) +
  geom_function(fun = dnorm, args = list(mean = mean(cuantia_total_simulada),
                                         sd = sd(cuantia_total_simulada)), 
                aes(color = "Normal Estándar"), size = 1, show.legend = T) +
  geom_function(fun = dnp, args = list(mu = mean(cuantia_total_simulada),
                                       sigma = sd(cuantia_total_simulada),
                                       asim = skewness(cuantia_total_simulada)),
                aes(color = "Normal Power"),show.legend = T, size = 1,
                linetype = "dashed") +
  scale_color_manual(name = "Distribución", values = c("springgreen", "brown")) +
  theme_bw() 
```



### Propuesta 2: Distribución Binomial Negativa + Distribución Gamma

```{r}
# Simulación de las cuantías individuales y totales
cuantia_total_simulada2 <- numeric(length(siniestros))
esperanzas_simuladas2 <- numeric(length(siniestros))
variancias_simuladas2 <- numeric(length(siniestros))
contador <- 0

for(i in siniestros){
  contador <- contador + 1
  pos <- rgamma(n = i, shape = alpha, scale = beta)
  esperanzas_simuladas2[contador] <- mean(pos)
  variancias_simuladas2[contador] <- var(pos)
  cuantia_total_simulada2[contador] <- sum(pos)
}

media_ej2 <- mean(esperanzas_simuladas2) # Esperanza del ejercicio
var_ej2 <- mean(variancias_simuladas2) # Variancia del ejercicio

media_cuantia_total2 <- media_ej2 * media_siniestros_simulados1

datos_simulados$prop2 <- cuantia_total_simulada2
```


```{r}
z = qnorm(0.99)
y2 = z + (skewness(cuantia_total_simulada2)/6)*(z^2 - 1)

prop2 <- data.frame(
  RS = c("1%", "3%"),
  PP = c(mean(cuantia_total_simulada2), mean(cuantia_total_simulada2)),
  PR = c(mean(cuantia_total_simulada2)*1.01, mean(cuantia_total_simulada2)*1.03),
  P_N = c(z*sd(cuantia_total_simulada2)+mean(cuantia_total_simulada2), z*sd(cuantia_total_simulada2)+mean(cuantia_total_simulada2))
) |> 
  mutate(MSM_n = P_N - PR) |> 
  mutate(P_NP = c(y2*sd(cuantia_total_simulada2)+mean(cuantia_total_simulada2), y2*sd(cuantia_total_simulada2)+mean(cuantia_total_simulada2))) |> 
  mutate(MSM_np = P_NP - PR)
```

```{r}
datos_simulados |> 
  ggplot() +
  aes(x = cuantia_total_simulada2) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, fill = "grey21") +
  labs(x = "Cuantía total", y = "Densidad") +
  scale_x_continuous(breaks = c(1650000000, 1770000000,1890000000)) +
  geom_function(fun = dnorm, args = list(mean = mean(cuantia_total_simulada2),
                                         sd = sd(cuantia_total_simulada2)), 
                aes(color = "Normal Estándar"), size = 1, show.legend = T) +
  geom_function(fun = dnp, args = list(mu = mean(cuantia_total_simulada2),
                                       sigma = sd(cuantia_total_simulada2),
                                       asim = skewness(cuantia_total_simulada2)),
                aes(color = "Normal Power"),show.legend = T, size = 1,
                linetype = "dashed") +
  scale_color_manual(name = "Distribución", values = c("springgreen", "brown")) +
  theme_bw() 
```



```{r}
ggplot() +
  aes(x = cuantia_total_simulada2) +
  geom_density()
```



### Propuesta 3: Distribución Poisson + Distribución Log-Normal


```{r}
# Simulación de las cuantías individuales y totales
media_siniestros_simulados3 <- mean(siniestros_poisson)
var_siniestros_simulados3 <- var(siniestros_poisson)

cuantia_total_simulada3 <- numeric(length(siniestros_poisson))
esperanzas_simuladas3 <- numeric(length(siniestros_poisson))
variancias_simuladas3 <- numeric(length(siniestros_poisson))
contador <- 0

for(i in siniestros_poisson){
  contador <- contador + 1
  pos <- rlnorm(n = i, meanlog = mu_est, sdlog = sigma_est)
  esperanzas_simuladas3[contador] <- mean(pos)
  variancias_simuladas3[contador] <- var(pos)
  cuantia_total_simulada3[contador] <- sum(pos)
}

media_ej3 <- mean(esperanzas_simuladas3) # Esperanza del ejercicio
var_ej3 <- mean(variancias_simuladas3) # Variancia del ejercicio

media_cuantia_total3 <- media_ej3 * media_siniestros_simulados3

datos_simulados$prop3 <- cuantia_total_simulada3
```


```{r}
z = qnorm(0.99)
y3 = z + (skewness(cuantia_total_simulada3)/6)*(z^2 - 1)

prop3 <- data.frame(
  RS = c("1%", "3%"),
  PP = c(mean(cuantia_total_simulada3), mean(cuantia_total_simulada3)),
  PR = c(mean(cuantia_total_simulada3)*1.01, mean(cuantia_total_simulada3)*1.03),
  P_N = c(z*sd(cuantia_total_simulada3)+mean(cuantia_total_simulada3), z*sd(cuantia_total_simulada3)+mean(cuantia_total_simulada3))
) |> 
  mutate(MSM_n = P_N - PR) |> 
  mutate(P_NP = c(y3*sd(cuantia_total_simulada3)+mean(cuantia_total_simulada3), y3*sd(cuantia_total_simulada3)+mean(cuantia_total_simulada3))) |> 
  mutate(MSM_np = P_NP - PR)
```


```{r}
datos_simulados |> 
  ggplot() +
  aes(x = cuantia_total_simulada3) +
  geom_histogram(aes(y = after_stat(density)), bins = 50, fill = "grey21") +
  labs(x = "Cuantía total", y = "Densidad") +
  scale_x_continuous(breaks = c(1650000000, 1770000000,1890000000)) +
  geom_function(fun = dnorm, args = list(mean = mean(cuantia_total_simulada3),
                                         sd = sd(cuantia_total_simulada3)), 
                aes(color = "Normal Estándar"), size = 1, show.legend = T) +
  geom_function(fun = dnp, args = list(mu = mean(cuantia_total_simulada3),
                                       sigma = sd(cuantia_total_simulada3),
                                       asim = skewness(cuantia_total_simulada3)),
                aes(color = "Normal Power"),show.legend = T, size = 1, 
                linetype = "dashed") +
  scale_color_manual(name = "Distribución", values = c("springgreen", "brown")) +
  theme_bw() 
```

```{r}
ggplot() +
  aes(x = cuantia_total_simulada3) +
  geom_density()
```
